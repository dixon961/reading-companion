
# Соглашения по разработке проекта "Интерактивный компаньон"

## 1. Введение

Этот документ определяет основные технические соглашения, архитектурные решения и процессы разработки для данного проекта. Его цель — обеспечить консистентность, высокое качество кода и упростить процесс разработки. Проект разрабатывается с прицелом на "Enterprise-ready" подходы, но с прагматизмом, уместным для личного проекта.

## 2. Структура проекта (Монорепозиторий)

Проект использует монорепозиторий с четким разделением на фронтенд и бэкенд.

```
/
├── backend/         # Go-приложение (API и бизнес-логика)
├── frontend/        # React-приложение (UI)
├── .gitignore
├── docker-compose.yml # Описание сервисов для локального запуска
├── Makefile         # Утилита для автоматизации команд
├── SPECIFICATION.md # Техническое задание на разработку
└── CONVENTIONS.md   # Этот файл
```

## 3. Технологический стек

| Компонент | Технология | Примечание |
| :--- | :--- | :--- |
| **Backend** | Go (Golang) | Основной язык для серверной части. |
| **Frontend** | React (Vite) | SPA-фреймворк для пользовательского интерфейса. |
| **База данных**| PostgreSQL | Основная реляционная СУБД. |
| **Контейнеризация** | Docker, Docker Compose | Для локального развертывания и обеспечения консистентности окружения. |
| **Миграции БД** | golang-migrate/migrate | Управление версиями схемы БД. |
| **Работа с БД** | sqlc | Генерация типизированного Go-кода из SQL-запросов. |
| **Конфигурация** | Viper | Управление конфигурацией приложения. |
| **Тестирование**| testcontainers-go| Запуск интеграционных тестов в изолированных Docker-контейнерах. |

---

## 4. Backend Conventions (Go)

### 4.1. Архитектура

Приложение следует принципам **Clean Architecture / Hexagonal Architecture** с четким разделением на три слоя:

1.  **API Layer (Controllers/Handlers):** Находится в пакете `internal/api/`. Отвечает за прием HTTP-запросов, их валидацию, десериализацию, вызов соответствующего сервиса и сериализацию ответа. Не содержит бизнес-логики.
2.  **Service Layer (Services/Usecases):** Находится в пакете `internal/service/`. Содержит всю бизнес-логику приложения. Оперирует доменными моделями, не зависит от деталей транспорта (HTTP) или хранения (БД). Вызывает методы репозиториев для работы с данными.
3.  **Repository Layer (Repositories/DAL):** Находится в пакете `internal/repository/`. Является реализацией интерфейсов, определенных в сервисном слое. Отвечает за все взаимодействие с базой данных (выполнение SQL-запросов).

### 4.2. Стиль кода и форматирование

-   **Форматирование:** Весь код должен быть отформатирован с помощью `gofmt`.
-   **Линтинг:** Используется `golangci-lint` для статического анализа кода. Конфигурационный файл `.golangci.yml` должен находиться в корне `backend/`.

### 4.3. API Conventions

-   **Стиль:** RESTful.
-   **Формат данных:** `application/json` для всех запросов и ответов.
-   **Именование ключей JSON:** `snake_case` (например, `session_id`).
-   **Структура ответа при ошибке:** Все ошибки API должны возвращаться в едином формате:
    ```json
    {
      "error": {
        "code": "UNIQUE_CONSTRAINT_VIOLATED",
        "message": "Пользователь с таким email уже существует."
      }
    }
    ```
-   **Статус-коды HTTP:** Используются стандартные статус-коды (200, 201, 204, 400, 401, 403, 404, 500).

### 4.4. Конфигурация

-   Используется библиотека `Viper`.
-   Приоритет конфигурации: **Переменные окружения > Файл `config.yml` > Значения по умолчанию**.
-   Файл `config.yml.example` с примером структуры должен находиться в проекте. Секретные данные (ключи, пароли) не должны коммититься в репозиторий.

### 4.5. Доступ к данным и миграции

-   **Генерация кода:** Для взаимодействия с БД используется `sqlc`. SQL-запросы располагаются в `.sql` файлах, из которых генерируется типизированный Go-код.
-   **Миграции:** Для управления схемой БД используется `golang-migrate/migrate`. Файлы миграций именуются в формате `[версия]_[название].up.sql` и `[версия]_[название].down.sql`.

### 4.6. Аутентификация

-   **Механизм:** JWT (JSON Web Tokens).
-   **Поток:**
    1.  Пользователь регистрируется/логинится через эндпоинты `/api/v1/auth/register` и `/api/v1/auth/login`.
    2.  Сервер возвращает `access_token` и `refresh_token`.
    3.  Клиент отправляет `access_token` в заголовке `Authorization: Bearer <token>` при каждом защищенном запросе.

### 4.7. Логирование

-   Используется структурированное логирование в формате JSON. Рекомендуемая библиотека — `slog` (стандартная с Go 1.21) или `zerolog`.
-   Все логи должны содержать контекст (например, `user_id`, `request_id`).

---

## 5. Frontend Conventions (React)

### 5.1. Структура директорий

Используется стандартная для React-приложений структура директории `src/`:

-   `src/components/`: Переиспользуемые UI-компоненты.
-   `src/pages/`: Компоненты-страницы.
-   `src/hooks/`: Пользовательские хуки.
-   `src/api/`: Функции для взаимодействия с бэкенд API.
-   `src/store/` или `src/context/`: Логика управления состоянием.

### 5.2. Управление состоянием

-   Для простых случаев используется **React Context API**.
-   Для локального состояния компонентов используются **React Hooks** (`useState`, `useEffect`, etc.).

### 5.3. Стилизация

-   Рекомендуется использовать **CSS Modules** для инкапсуляции стилей компонентов.
-   Для сложных компонентов с множественными состояниями рекомендуется использовать **CSS-in-JS** библиотеки (например, styled-components).

### 5.4. Паттерны проектирования

-   Для компонентов с множественными режимами отображения используется **условный рендеринг**.
-   Для компонентов с переключаемыми состояниями используется **паттерн состояния** с `useState` и `useReducer`.

### 5.5. Мультиязычность

-   Для поддержки нескольких языков интерфейса используется кастомное решение на основе React Context.
-   Файлы локализации хранятся в директории `src/i18n/` в формате JSON, отдельно для каждого языка (например, `en.json`, `ru.json`).
-   Все текстовые строки в компонентах вынесены в файлы локализации и используются через хук `useLanguage()` с функцией `t()` для получения перевода.
-   Язык по умолчанию - русский (ru), с возможностью переключения на английский (en).
-   Выбор языка сохраняется в localStorage пользователя.
-   Для переключения языка используется компонент `LanguageSelector`.

---

## 6. Тестирование

-   **Unit-тесты:** Покрывают бизнес-логику в **Service Layer**. Зависимости (репозитории) должны мокироваться с помощью интерфейсов.
-   **Интеграционные тесты:** Покрывают взаимодействие **Repository Layer** с базой данных. Для запуска используется библиотека **`testcontainers-go`**, которая автоматически поднимает и останавливает временный контейнер с PostgreSQL для каждого тестового запуска.

---

## 7. Development Workflow

### 7.1. Git

-   **Ветки:** Разработка ведется в feature-ветках, которые создаются от основной ветки (`main` или `develop`).
-   **Pull Requests (PR):** Все изменения вливаются в основную ветку только через Pull Request'ы.
-   **Формат коммитов:** Используется стандарт **Conventional Commits**. Это позволяет автоматически генерировать changelog и делает историю понятной.
    -   `feat:`: Новая функциональность.
    -   `fix:`: Исправление бага.
    -   `docs:`: Изменения в документации.
    -   `style:`: Форматирование, исправление опечаток.
    -   `refactor:`: Рефакторинг кода без изменения функциональности.
    -   `test:`: Добавление или исправление тестов.
    -   `chore:`: Обслуживающие изменения (обновление зависимостей, настройка сборки).

### 7.2. Makefile

Для упрощения рутинных задач используется `Makefile` в корне проекта.

**Примерные цели:**

-   `make build`: Сборка бинарных файлов фронтенда и бэкенда.
-   `make run`: Запуск всего проекта через `docker-compose up`.
-   `make stop`: Остановка проекта (`docker-compose down`).
-   `make test`: Запуск всех тестов (unit и интеграционных).
-   `make lint`: Запуск линтеров для бэкенда и фронтенда.
-   `make migrate-up`: Применение последней миграции БД.

### 7.3. Docker

-   Файл `docker-compose.yml` в корне проекта определяет сервисы: `backend`, `frontend` (если он обслуживается Nginx) и `postgres`.
-   Он должен быть настроен так, чтобы команда `docker compose up -d` полностью запускала рабочее окружение локально.

### 7.4. Документация

-   `README.md` в корне проекта должен содержать краткое описание проекта и инструкцию по запуску.
-   `SPECIFICATION.md` в корне проекта содержит техническое задание на разработку проекта.
-   Важные и нетривиальные участки кода должны быть прокомментированы.
