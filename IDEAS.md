Конечно. Вот полное и финальное Техническое Задание, включающее все наши обсуждения и последние правки.

---

### Техническое Задание: Интерактивный компаньон для чтения

**Версия:** 1.3
**Дата:** 16.07.2025

### 1. Общее описание и цели системы

**1.1. Назначение системы:**
Система "Интерактивный компаньон для чтения" (далее — "Система") предназначена для помощи пользователю в обработке и усвоении информации из прочитанных книг. Система должна преобразовывать пассивный процесс разбора текстовых пометок (хайлайтов) в интерактивный диалог, стимулирующий рефлексию и создание качественных, осмысленных заметок.

**1.2. Цели создания системы:**
*   **Снижение когнитивной нагрузки:** Уменьшить умственные усилия, необходимые для начала и выполнения работы по обработке большого объема текстовых пометок.
*   **Повышение качества усвоения материала:** Способствовать более глубокому пониманию прочитанного за счет стимуляции пользователя к переформулированию и анализу каждой пометки.
*   **Оптимизация процесса создания заметок:** Ускорить и упростить создание атомарных, готовых к использованию заметок для персональных баз знаний (например, Obsidian).
*   **Геймификация рутины:** Превратить монотонную задачу в увлекательный и мотивирующий интерактивный процесс.

**1.3. Основные участники (Роли):**
*   **Пользователь:** Единственный участник системы.

**1.4. Общий сценарий использования:**
1.  Пользователь аутентифицируется в Системе.
2.  Пользователь инициирует новую "сессию разбора" или выбирает существующую из истории.
3.  При новой сессии Пользователь загружает текстовый файл, содержащий его пометки (хайлайты) из книги.
4.  Система обрабатывает файл и последовательно, по одной, отображает каждую пометку.
5.  Для каждой пометки Система генерирует и отображает открытый вопрос, побуждающий к анализу.
6.  Пользователь вводит свой текстовый ответ на этот вопрос.
7.  Система сохраняет пару "Вопрос-Ответ" и переходит к следующей пометке.
8.  После разбора всех пометок Система предоставляет Пользователю возможность выгрузить итоговый конспект в виде отформатированного текстового файла (например, Markdown).

### 2. Функциональные требования к пользовательскому интерфейсу (UI)

**2.1. Общие требования к UI:**
*   **Минимализм:** Интерфейс должен быть предельно простым, чистым и свободным от отвлекающих элементов.
*   **Адаптивность:** Интерфейс должен корректно отображаться и быть удобным для использования как на настольных компьютерах, так и на мобильных устройствах.

**2.2. Главный экран:**
*   **Назначение:** Точка входа для пользователя.
*   **Элементы:**
    *   Кнопка "Начать новую сессию", открывающая диалог создания сессии.
    *   **Диалог создания сессии:**
        *   Поле для загрузки файла. Должно быть указание на поддерживаемые форматы (например, "Загрузите .txt файл, поддерживается экспорт из Kon-Tiki 2").
        *   **Опциональное поле "Название сессии"**: Пользователь может сразу задать имя сессии. Если поле оставить пустым, имя будет сгенерировано автоматически (например, из имени файла).
    *   **Секция "История сессий":** Список предыдущих сессий. Каждый элемент должен содержать:
        *   Название сессии.
        *   **Иконка "Переименовать"**, позволяющая изменить название сессии.
        *   Дата и время начала сессии.
        *   Индикатор прогресса.

**2.3. Экран "Сессия разбора" / Основной рабочий экран:**
*   **Назначение:** Главный экран, где происходит основной интерактивный процесс.
*   **Элементы:**
    *   Индикатор прогресса (например, "Пометка 3 из 42").
    *   Область отображения текущей пометки (хайлайта).
    *   Область отображения вопроса от LLM.
    *   Многострочное текстовое поле для ответа пользователя.
    *   Кнопка "Далее" / "Ответить".
    *   Кнопка "Пропустить" текущую пометку.
    *   Кнопка "Сгенерировать другой вопрос" для запроса нового варианта вопроса у LLM.

**2.4. Экран "Завершение сессии" / Экран результатов:**
*   **Назначение:** Отображается после обработки всех пометок.
*   **Элементы:**
    *   Сообщение об окончании сессии.
    *   Кнопка "Скачать конспект (.md)".
    *   Кнопка "Начать новую сессию".

### 3. Требования к управлению историей сессий

**3.1. Хранение сессий:**
*   Система должна сохранять каждую начатую сессию разбора в базе данных.
*   Для каждой сессии сохраняются: ID, редактируемое название (`name`), исходные пометки, прогресс, статус (`в процессе`, `завершена`), а также весь диалог (пометки, вопросы, ответы).

**3.2. Продолжение прерванной сессии:**
*   Пользователь должен иметь возможность вернуться к прерванной сессии из списка истории и продолжить с того места, где остановился.

**3.3. Просмотр завершенной сессии:**
*   Пользователь должен иметь возможность просматривать архив завершенных сессий и скачивать их итоговый конспект.

**3.4. Удаление сессии:**
*   Пользователь должен иметь возможность удалять сессии из истории с запросом на подтверждение.

### 4. Требования к серверной части (Backend) и логике системы

**4.1. Общая архитектура:**
*   Клиент-серверная архитектура (SPA Frontend + Backend).
*   Взаимодействие по RESTful API с передачей данных в формате JSON.

**4.2. Детальное описание API эндпоинтов:**

---
**Эндпоинт 1: Создание новой сессии**
*   **Маршрут:** `POST /api/sessions`
*   **Назначение:** Создает новую сессию разбора из файла с пометками.
*   **Тело запроса:** `multipart/form-data`
    *   `file` (file, required): Текстовый файл (.txt) с пометками.
    *   `session_name` (string, optional): Пользовательское название для сессии.
*   **Логика на сервере:**
    1.  Проверить наличие и формат файла.
    2.  Распарсить файл в массив строк-пометок. Учесть необходимость поддержки разных разделителей (пустая строка, специальный символ). **Запланировать исследование формата экспорта из Onyx Neo Reader.**
    3.  Проверить, что количество пометок не меньше минимального порога (например, 3).
    4.  Создать новую запись `Session` в БД: сгенерировать `session_id`, использовать `session_name` или имя файла, установить `status: 'in_progress'`.
    5.  Сохранить каждую пометку как запись `Highlight`, привязанную к `session_id`.
    6.  Взять первую пометку (`index=0`) и вызвать LLM для генерации первого вопроса.
*   **Успешный ответ:** `201 Created`
    *   **Тело ответа (JSON):**
        ```json
        {
          "sessionId": "uuid-v4-string",
          "name": "Название сессии",
          "totalHighlights": 42,
          "nextStep": {
            "highlightIndex": 0,
            "highlightText": "Текст первой пометки...",
            "question": "Сгенерированный LLM вопрос к первой пометке?"
          }
        }
        ```
*   **Ответы с ошибкой:**
    *   `400 Bad Request`: Если файл не предоставлен, пуст, имеет неверный формат или содержит менее 3 пометок.

---
**Эндпоинт 2: Обработка ответа и переход к следующему шагу**
*   **Маршрут:** `POST /api/sessions/{session_id}/process`
*   **Назначение:** Сохраняет ответ пользователя на текущую пометку и запрашивает следующую.
*   **Тело запроса:** `JSON`
    *   `highlightIndex` (number, required): Индекс обработанной пометки.
    *   `userAnswer` (string, required): Текст ответа, введенный пользователем.
*   **Логика на сервере:**
    1.  Найти сессию по `session_id`.
    2.  Сохранить `userAnswer` в запись `Interaction`, связанную с `highlightIndex`.
    3.  Определить индекс следующей пометки (`nextIndex = highlightIndex + 1`).
    4.  Если `nextIndex` существует в рамках сессии:
        *   Получить текст следующей пометки.
        *   Вызвать LLM для генерации вопроса к ней.
        *   Вернуть данные для следующего шага.
    5.  Если пометок больше нет:
        *   Изменить `status` сессии на `'completed'`.
        *   Вернуть сообщение о завершении.
*   **Успешный ответ:** `200 OK`
    *   **Тело ответа (JSON, если есть следующий шаг):**
        ```json
        {
          "nextStep": {
            "highlightIndex": 1,
            "highlightText": "Текст следующей пометки...",
            "question": "Новый сгенерированный вопрос?"
          }
        }
        ```
    *   **Тело ответа (JSON, если это был последний шаг):**
        ```json
        {
          "status": "completed",
          "message": "Сессия успешно завершена."
        }
        ```*   **Ответы с ошибкой:**
    *   `404 Not Found`: Если сессия с таким `session_id` не найдена.

---
**Эндпоинт 3: Повторная генерация вопроса**
*   **Маршрут:** `POST /api/sessions/{session_id}/regenerate_question`
*   **Назначение:** Запрашивает новый вариант вопроса для той же пометки.
*   **Тело запроса:** `JSON`
    *   `highlightIndex` (number, required): Индекс текущей пометки.
*   **Логика на сервере:**
    1.  Найти сессию и текст пометки по `highlightIndex`.
    2.  Вызвать LLM с промптом, содержащим инструкцию сгенерировать **альтернативный** вопрос.
    3.  Сохранить новый вопрос в историю вопросов для данной пометки в записи `Interaction`.
*   **Успешный ответ:** `200 OK`
    *   **Тело ответа (JSON):** `{ "newQuestion": "Новый сгенерированный вопрос?" }`
*   **Ответы с ошибкой:**
    *   `404 Not Found`: Сессия или пометка не найдена.
    *   `503 Service Unavailable`: Если LLM недоступна (см. раздел 5.2.1).

---
**Эндпоинт 4: Изменение сессии (переименование)**
*   **Маршрут:** `PATCH /api/sessions/{session_id}`
*   **Назначение:** Позволяет изменять атрибуты сессии, например, название.
*   **Тело запроса:** `JSON`
    *   `name` (string, required): Новое название сессии.
*   **Логика на сервере:** Найти сессию по `session_id` и обновить поле `name`.
*   **Успешный ответ:** `200 OK`
    *   **Тело ответа (JSON):** Полный обновленный объект сессии.

---
**Прочие эндпоинты:**
*   `GET /api/sessions`: Возвращает массив всех сессий пользователя с их метаданными.
*   `GET /api/sessions/{session_id}`: Возвращает полную информацию о сессии, включая все пометки и диалоги.
*   `DELETE /api/sessions/{session_id}`: Удаляет сессию и все связанные с ней данные.

### 5. Нефункциональные требования
_(Разделы 5.1 - 5.6 остаются без изменений, включая детальные сценарии обработки ошибок и формат итогового конспекта)_

**4.3. Взаимодействие с LLM:**
*   Вся логика общения с LLM инкапсулирована на бэкенде.
*   Подключение к LLM должно быть конфигурируемым (URL, модель).
*   Бэкенд отвечает за формирование системных промптов, определяющих роль и задачу LLM.

**4.4. Требования к базе данных:**
*   Использование реляционной или документо-ориентированной БД.
*   Основные сущности: `Sessions` (метаданные), `Highlights` (пометки), `Interactions` (диалоги).

### 5. Нефункциональные требования

**5.1. Производительность:**
*   Отклик UI < 100 мс.
*   Время генерации вопроса LLM < 5-7 секунд (с отображением индикатора загрузки).

**5.2. Надежность и отказоустойчивость:**
*   **5.2.1. Четкие сценарии обработки ошибок:**
    *   **Сценарий "Пустой или невалидный файл":** Бэкенд возвращает `400 Bad Request` с сообщением "Файл пуст или имеет неверный формат". Фронтенд отображает ошибку.
    *   **Сценарий "Недостаточно пометок":** Если после парсинга пометок меньше минимального порога (например, 3), бэкенд возвращает `400 Bad Request` с сообщением "Для начала сессии необходимо как минимум 3 пометки". Фронтенд отображает ошибку.
    *   **Сценарий "Сбой LLM":** При сбое ответа от LLM, бэкенд предпринимает 1-2 попытки повторного запроса. Если все попытки неудачны, возвращается ошибка `503 Service Unavailable`. Фронтенд показывает дружелюбное сообщение и оставляет активной кнопку повторной генерации.

**5.3. Безопасность:**
*   Архитектура должна предусматривать возможность добавления аутентификации в будущем.
*   Использование локальных LLM обеспечивает конфиденциальность данных по умолчанию.

**5.4. Масштабируемость и расширяемость:**
*   Архитектура должна позволять легко добавлять поддержку новых LLM-моделей и нового функционала.

**5.5. Развертывание и поддержка:**
*   Рекомендуется использование контейнеризации (Docker).
*   Ключевые параметры должны быть вынесены в переменные окружения.

**5.6. Формат итогового конспекта:**
*   **Назначение:** Определить стандартную структуру итогового файла, который получает пользователь.
*   **Формат:** Markdown (.md).
*   **Структура:**
    1.  Главный заголовок: Название сессии.
    2.  Дата: Дата завершения сессии.
    3.  Разделитель: Горизонтальная черта.
    4.  Тело конспекта: Последовательность блоков, по одному на каждую обработанную пометку.
    5.  **Структура блока:** Цитата (>), Вопрос ассистента, Ответ пользователя.

*   **Пример шаблона (`template.md`):**
    ```markdown
    # Конспект по книге: Проектирование высоконагруженных систем
    **Дата разбора:** 16.07.2025
    
    ---
    
    > The core principle of Dependency Injection is to decouple components by providing their dependencies from an external source rather than having them create dependencies themselves.
    
    **_Вопрос ассистента: Как бы ты объяснил этот принцип на простом примере из реальной жизни?_**
    
    Это как приготовление торта. Можно самому печь коржи и делать крем (создавать зависимости). А можно получить готовые компоненты извне (из магазина). Второй подход проще и позволяет легко заменять компоненты, не меняя основной рецепт.
    
    ---
    
    > A `volatile` variable ensures that any write to it is immediately visible to other threads.
    
    **_Вопрос ассистента: В чем ключевое отличие от обычной переменной в многопоточной среде?_**
    
    Обычная переменная может кэшироваться в потоке, из-за чего другие потоки увидят ее новое значение с задержкой. Volatile заставляет каждый поток читать значение напрямую из основной памяти, гарантируя актуальность.
    ```
